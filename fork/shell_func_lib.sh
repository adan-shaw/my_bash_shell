# , , , , ,,, , , , ,,, ,,, , , ,  , , , ,, ,  , , ,, , , , , , ,, , ,, ,, ,
# text rules simple version for public:
# !_1.'行-字符长度'测试(how many char in one line):
# 1111111111111111111111111111111111111111111111111111111111111111111111111
# 邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵
# *************************************************************************
# !_2.标题命名规则(headline named rules):
# 		!_1.xxx:	'level 1' headline
# 		!_2.xxx:	'level 1' headline
# 		!_3.xxx:	'level 1' headline
# 			@_2.xxx:	'level 2' headline
# 				#_3.xxx:	'level 3' headline
# !_3.统一使用english US(英文)的标点符号, 作为编码统一标点字符.
# !_4.文件更改日志(file changed log):
# 		...
# , , , , ,,, , , , ,,, ,,, , , ,  , , , ,, ,  , , ,, , , , , , ,, , ,, ,, ,

#!/bin/sh


# 1.posix shell 函数声明特点:
if false; then
echo "
	*1.shell 函数不需要不需要定义形参, 有多少实参直接传进去即可.
		 shell 通过$0 = 函数名/shell 脚本自身的名字, 
		 $1 = 第一个实参, $2 = 第二个实参, 如此类推.

	*2.shell 函数的返回值, 必须为'数字'字符串, 
		 而且数字范围必须为[0,255], -1=255; 一共8bit.
		 不能为英文字母或者其它返回值.

	*3.调用函数的时候, 获取返回值, 有两种方法:
		 3.1: 通过内建宏变量'$?', 获取最近一次函数调用/子进程的结束返回值!!
		 			注意: 
						通过该方法获取的返回值, 期值范围必须为[0,255], 一共8bit.

		 3.2: 通过echo "" 回显字符串返回, 这样你可以返回任何你想返回的'字符串'or '数字'.
					但函数执行过程中, 不能echo 杂乱字符.

					或者返回结果, 过于复杂, 你可以直接echo "" > tmpfs 内存文件中,
					然后再通过tmpfs 内存文件的读写操作, 分析结果.

					通过echo "" 回显, 返回字符串/复杂数字时, 标准的调用方式是:
					tmp=$(function_name)
					# 错误方式:
						tmp=(function_name) # 错误!

					或者你不在意返回值, 那可以直接调用:
					(强烈建议, 自定义函数默认调用, 必须加';'结束符号, 以方便区分!!)
					function_name;
					此时, echo 所有输出, 将会直接打印到tty 中.

	*4.posix shell function 不支持function 关键字!!
		 所以, 只有bash shell, 都可以带关键字定义函数.
		 function func_name() {};# bash shell
		 func_name() {};# posix shell

	*5.posix or bash shell 都不允许存在空函数!! 会报错的
" > /dev/null
fi



#
# 2.posix shell 的函数定义样板:
#
ftest() {
	# 显示输入的第1,2,3 个参数
	echo $1 $2 $3

	# 显示输入的所有参数
	echo $*

	# 显示输入参数的个数
	echo $#

	# 返回常量字符串
	return "123"
}



#
# 4.关于posix shell 函数调用的阻塞与非阻塞问题:
#
:<<!
	posix shell函数只要在'tty前台'执行, 就一定是阻塞的.
	c语言执行函数的时候, 也肯定是阻塞的!!
	除非你新建一条线程, 去执行一个新的线程函数!!
	(但是此时, 这个函数已经不是普通函数了, 而是线程函数!!)

	wait 命令, 对posix shell 函数的影响:
		毫无影响!!
		posix shell 函数是阻塞的, 所以根本不需要使用wait 命令.
		posix shell 函数会自己返回一个值到"$?"内置宏中, 你也可以echo 回显打印返回.

	wait 命令的语义是:
		等待任意一个子进程结束, 获取其 exit "0" 返回值(同样是[0,255]的范围内取值)

	总结:
		wait 对函数无效, 不能用在函数身上!!
		shell 执行函数肯定是阻塞的, 如果弹到后台执行函数, 即新建一个子进程去执行该函数.
		这时候可以用wait, 因为你已经fork 一个子进程去执行这个函数了, 
		当然可以wait, 等待这个子进程结束.


#
# 误区1(阻塞函数与非阻塞函数):
#
阻塞函数:
# shell 执行函数, 全部都是阻塞的!! 因此"$?"内置宏, 会经常用来获取函数return 值
func_test "123"

非阻塞函数(其实没有非阻塞函数!!):
# 想要非阻塞执行函数, 请使用'&'. 很奇怪吧, shell中的自定义函数都可以后台执行!!
# 这shell中的自定义函数, 后台'&'执行, 实际上就是创建子进程去执行该‘shell中的自定义函数’.
func_test "123" &

	后台函数, 虽然是非阻塞的. 但你很难获取'其函数返回值'!!
	(已证实: 无论你怎样做, wait返回值$? 总是0)
	所以, 后台函数唯一可以获取返回值的方法:
		直接将结果返回值echo "" > tmpfs 然后结束!!
		不要期望wait, or $?.
		或者tmp=$()--> 这个实际是阻塞的, 不能放到后台运行!!
		因此, 打印到tmpfs 是这种函数返回结果的最佳方法.
!


# 非阻塞函数.(本函数只能 '&' 后台调用, 可以执行wait等待执行结束, 不可获取结果!!)
# 在fork_wait.sh 中做测试.
nonblocking_demo() {
	sleep 1
	echo "hello there, i'm nonblocking_demo(). 传入参数: $1"
	echo "返回值, 可取值的范围是[0,255]. 一共8bit."
	exit "66"
}



# 阻塞函数.(不需要wait 获取结果)
# 在shell_source.sh 中做测试
shell_func1() {
	echo "hello there, i'm shell_func_lib()."
	echo "你传入什么值, 我原路返回什么值, 主要显示如何传入值调用函数, or接收函数返回值."
	return $1
}



# 阻塞函数.(不需要wait 获取结果, 且可以返回字符串!! 不限于数字.)
# shell函数传递返回值的方式(新): 
#   利用echo/printf 回显打印, 和tmp=$() 反向管道, 阻塞获取‘shell函数’的STDOUT输出返回
#   这种方法, 要求你将'shell函数'过程中的大部分命令的输出, 全部 > /dev/null 消除,
#   仅保留返回值, 进行echo/printf 回显到STDOUT输出
#
# 这种方法, 定义的shell函数的用处是: 可以返回字符串, 不限于"数字"字符串!!
# return "数字", 只能返回"数字"字符串!!

# (新)echo/printf 回显值-返回函数:
# 在shell_source.sh 中做测试
echo2STDOUT() {
	ping 127.0.0.1 -c 4 > /dev/null
	# 传入什么, 返回什么
	echo "$1"
	#if[ $echo_return == "0" ];
	#echo "ok"
	#if[ $echo_return == "ok" ];
	#echo "fail"
	#if[ $echo_return == "fail" ];

	####失败, 还是阻塞的, 父进程会等待tmp=$() 反向管道结束, 才会继续!! 管道都是阻塞的!!
	#方便做异步执行测试(非阻塞)
	#sleep 1
	#########################################################################

	#这种函数, 反正都不需要return返回什么值了, 直接返回""更好
	return "0"
}



# 空函数测试(会报错的)
:<<!
function echo2STDOUT2() {
};
!

